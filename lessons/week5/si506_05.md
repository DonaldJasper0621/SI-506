# SI 506: Iteration and Control Flow, Part II

## Topics

1. Reference
2. Lecture data
3. Data handling: string manipulation
   1. Removing spaces in strings: `str.strip()`, `str.lstrip()`, `str.rstrip()`
   2. Method chaining
4. Additional control flow statements
   1. `break` statement
   2. `continue` statement
5. Indefinite iteration: `while` loop
   1. Infinite loops
   2. Challenge 01
   3. `while` loop `else` condition
   4. `while` loop and conditional statements
   5. `while` loop and the `range` type
   6. Challenge 02
   7. Built-in `input()` function
6. Data handling: truth value testing
   1. Working with `None` or blank values
   2. Handling ties when counting
7. Compound conditional statements
   1. Logical `and` operator
   2. Challenge 03
   3. Logical `or` operator
   4. Logical `not` operator
   5. Grouping related expressions
   6. Challenge 04

## 1.0 Reference

Bookmark the following
[w3schools](https://www.w3schools.com/python/default.asp) Python pages and/or have them open in a
set of browser tabs both during class and while working on this week's problem set:

* ["Python Built-in Functions"](https://www.w3schools.com/python/python_ref_functions.asp)
* ["Python Operators"](https://www.w3schools.com/python/python_operators.asp)
* ["Python List Methods"](https://www.w3schools.com/python/python_ref_list.asp)
* ["Python String Methods"](https://www.w3schools.com/python/python_ref_string.asp)
* ["Python Tuple Methods"](https://www.w3schools.com/python/python_ref_tuple.asp).

## 2.0 Lecture data

This week's lecture data was retrieved by accessing the US Department of Energy's
[National Renewable Energy Laboratory](https://www.nrel.gov/) (NREL)
[API](https://developer.nrel.gov/docs/transportation/alt-fuel-stations-v1/)
(Application Programming Interface). This involved utilizing the third-party Python
[Requests](https://requests.readthedocs.io/en/latest/) library to issue an HTTP GET request to
retrieve information about electric vehicle (EV) charging stations located in Ann Arbor and
Ypsilanti, Michigan.

Below is a description of the data retrieved for this week's lectures. Note that the data represents a
curated selection of information that can be sourced from the NREL's API.

| Column | Description |
|:-------|:------------|
| id                      | Unique identifer assigned to a station |
| station_name            | The name of the station |
| facility_type           | Facility type |
| access_code             | A description of who is allowed to access the station. |
| access_days_time        | Hours of operation |
| restricted_access       | For public stations, an indication of whether the station has restricted access, given as a boolean. |
| city                    | Municipality in which the station is located. |
| zip                     | The ZIP code (postal code) of the station's location. |
| street_address          | The street address of the station's location. |
| intersection_directions | Brief additional information about how to locate the station. |
| ev_network              | Network that maintains the station. |
| ev_connector_types      | Connector type(s) available at the station. |
| ev_dc_fast_num          | The number of DC Fast EVSE ports. |
| ev_level1_evse_num      | The number of Level 1 EVSE ports. |
| ev_level2_evse_num      | The number of Level 2 EVSE ports. |
| ev_other_evse           | The number and type of additional EVSE ports. |
| ev_pricing              | Pricing details. |
| date_last_confirmed     | The date the station's details were last confirmed. |

## 3.0 Data handling: string manipulation

When working with ever larger data sets do not assume that the data is "clean" or that all elements
are present. You should always check the data for missing or incomplete values and handle them
appropriately.

For example let's check what cities are represented in the data set:

```python
headers = STATIONS[0]  # column headers
stations = STATIONS[1:]  # data

# Lookup index
city_idx = headers.index("city")

cities = []
for station in stations:
    if station[city_idx] not in cities:
        cities.append(station[city_idx])

print(f"\n3.0.3 Cities = {cities}")  # [' Ann Arbor ', 'Ann Arbor', 'Ypsilanti ', ' Ann Arbor']
```

Unfortunately, all the string elements that comprise the `cities` list contain unexpected leading
and/or trailing spaces that complicate obtaining exact matches on the city names.

### 3.1 Removing spaces in strings: `str.strip([< chars >])`, `str.lstrip([< chars >])`, `str.rstrip([< chars >])`

Luckily, Python provides three built-in string methods that can be used to return a version of a
string with leading and/or trailing spaces removed.

`str.strip()` returns a "trimmed" version of the string with leading _and_ trailing spaces removed.

`str.lstrip()` returns a "trimmed" version of the string with leading spaces removed.

`str.rstrip()` returns a "trimmed" version of the string with trailing spaces removed.

```python
ann_arbor = " Ann Arbor ".strip()  # returns "Ann Arbor"

access_code = " public".lstrip()  # returns "public"

ypsi = "Ypsilanti ".rstrip()  # returns "Ypsilanti"
```

An optional `chars` argument can be passed to each method. Employ it to specify a set of characters
to be removed from the string. See the official Python documentation for
more information on the [`str.strip()`](https://docs.python.org/3/library/stdtypes.html#str.strip),
[`str.lstrip()`](https://docs.python.org/3/library/stdtypes.html#str.lstrip), and
[`str.rstrip()`](https://docs.python.org/3/library/stdtypes.html#str.rstrip) behaviors when the
`chars` argument is employed.

```python
si506 = "www.si506.org".strip("gorw.")  # returns "si506"
```

### 3.2 Method chaining

Recall that object methods are _called_ using dot (`.`) notation. If a method "signature" includes
one or more _parameters_, these can be passed to the method as comma-separated _arguments_ that are
included inside the method's parentheses `()`.

Method calls can also be "chained". Each method call returns a value (object) to which the next
method call is bound. Method chaining is a common pattern in Python programming. It is employed to streamline code and reduce the number of intermediate variables required to store the results of
each method call.

String manipulation is a common use case for method chaining. In the example below the `data` string
is stripped of leading and trailing spaces before being split into a list of city names.

```python
data = " ann arbor , chelsea, dexter ,  saline, ypsilanti "

cities = data.strip().split(", ") # remove leading and trailing spaces and split the string

# ['ann arbor ', 'chelsea', 'dexter ', ' saline', 'ypsilanti']
```

The order of operations matters. If you lose track of the object type returned by each chained
method call you may trigger a runtime exception.

```python
# WARN: wrong order of operations
cities = data.split(", ").strip()  # Triggers runtime exception

# AttributeError: 'list' object has no attribute 'strip'
```

Further work is required to clean up the city names. You can employ a `for` loop and method chaining
to eliminate the remaining extraneous spaces in the list elements and ensure that each city name is capitalized as expected (e.g., "ann arbor" -> "Ann Arbor").

```python,
for i in range(len(cities)):
    cities[i] = cities[i].strip().title()
```

:bulb: The `str.title()` method capitalizes the first letter of _each_ word in a string;
`str.capitalize()` capitalizes only the first character in a string.

String manipulation and chained method calls will feature prominently in this week's lectures and
problem set.

## 4.0 `break` and `continue` statements

You can interrupt control flow inside a loop using the `break` and `continue` statements.

### 4.1 `break` statement

The `break` statement is employed in a `for` loop to exit the loop and proceed to the next statement
in the code. Any statements _inside_ the loop that follow the `break` statement will be ignored. The
break statement is usually triggered by a specified condition. Using a `break` statement prevents
unnecessary looping and can result in performance gains if the sequence being looped over is large.

For example, if you need to confirm that the data set includes at least one Ypsilanti EV station, the
following loop, which leverages the "headers" list to look up the city column's index, will provide
you with the answer:

```python
has_ypsi = False
for station in stations:
    if station[city_idx].strip().lower() == "ypsilanti":
        has_ypsi = True
        break  # exit loop
```

Use of the `break` statement in the `if` block ensures that the loop is terminated as soon as the
first Ypsilanti station is encountered since, having located a Ypsilanti station, no need exists
to continue iterating over the remaining stations.

### 4.2 `continue` statement

The `continue` statement is employed in a `for` loop to terminate the _current_ loop iteration and
proceed directly to the next iteration in the loop (if any), skipping any trailing statements.

In the example below, the goal is to return a list of EV charging stations located outside downtown
Ann Arbor and the University of Michigan campus.

A function named `get_element()` provides a lookup capability that simplifies retrieval of nested
list elements. The function is employed to access each station's zip code, city, street address,
station name, and access code elements.

The `continue` statement is employed to skip stations located in the zip codes "48104" and "48109".

```python
outskirts = []
for station in stations:
    zip_code = get_element(station, headers, "zip")
    city = get_element(station, headers, "city")
    street = get_element(station, headers, "street_address")
    name = get_element(station, headers, "station_name")
    access_code = get_element(station, headers, "access_code")
    if zip_code in ("48104", "48109"):
        continue  # ignore downtown Ann Arbor and U-M campus zip codes
    outskirts.append(f"{name} ({access_code}), {street}, {city}, MI {zip_code}")
```

## 5.0 Indefinite iteration: the `while` loop

The `while` loop repeats a set of one or more statements _indefinitely_; that is, until a condition
is imposed that evaluates to `False` and terminates the loop.

```commandline
while < expression >:
    < statement A >
    < statement B >
```

In the example below, a counter `i` is initialized with a default value of zero (`0`). The `while`
loop, once initiated, will continue to iterate over the loop block _indefinitely_ until the
expression `i < 5` returns `False`. Note that the only way to terminate the looping operation is
to increment the counter value by `1` _inside the loop block.

```python
i = 0
while i < 5:
    print(i)
    i += 1 # increment (addition assignment operator)
```

If you interested in returning a count of the number of ChargePoint Network stations in `stations`
you can leverage the accumulator pattern using a `for` loop and "counter" variable:

```python
chargepoint_count = 0
for station in stations:
    ev_network = get_element(station, headers, "ev_network")
    if ev_network.strip().lower() == "chargepoint network":
        chargepoint_count += 1
```

You could reimplement the task employing a `while` loop:

```python
chargepoint_count = 0
i = 1  # skip the header list
while i < len(stations):
    ev_network = get_element(stations[i], headers, "ev_network")
    if ev_network.strip().lower() == "chargepoint network":
        chargepoint_count += 1
    i += 1  # increment
```

:bulb: In the above example opting for _indefinite_ iteration (the `while` loop) adds unnecessary
complexity to the solution. The choice also risks triggering an infinite loop if the counter `i` is
not incremented correctly. In short, approach the `while` loop _with caution_.

### 5.1 Infinite loops

If a `while` loop is implemented incorrectly it will trigger an _infinite loop_, a runaway process
that, over time, will consume ever greater memory resources to the detriment of your both your
operatings system and hardware (you will hear the fans kick on as the laptop's internal
temperature rises). Eventually, your system will crash unless you kill the process.

Typically, a `while` loop is implemented when the number of required iterations is unknown. There
are other use cases, one of which we will explore below.

The following example is guaranteed to trigger an infinite loop since the `while` condition remains
`True` indefinitely:

```python
while True:
    print("infinite loop triggered") # Don't do this
```

You can tame a `while` loop initialized to `True` by adding a conditional statement that includes a
`break` statement in the loop block.

```python
i = 0
while True:
    print('infinite loop triggered')
    if i == 5:
        print('infinite loop terminated\n')
        break # exit the loop
    i += 1 # increment (note indention)
```

:exclamation: if you trigger an infinite loop while running your module in VS Code click the
terminal pane's trash can icon in order to kill the session and end the runaway process.

### 5.2 Challenge 01

__Task__: Return the __index__ of the first nested list in `stations` that represents an EV station
located in Ypsilanti, Michigan.

1. Uncomment the partially implemented `while` loop.

2. Inside the `while` loop, call the function `get_station_element()` and pass to it the arguments
   required to return the "city" element. Assign the return value of the function call to a
   variable name of your own choosing (e.g., `city`).

3. write an `if` statement that compares `city` to the string "ypsilanti". Perform a
   __case insensitive__ comparison and test the two strings for __equality__.

4. If a match is obtained call the appropriate list method _inside_ the `if` statement block to
   return the __index__ of the __nested list__ that represents the Ypsilanti station
   encountered in `stations` (this should be the first Ypsi ev station). Assign the value to a
   variable name of your own choosing (e.g., `ypsi_station_idx`).

5. Inside the `if` statement block, but after the variable assignment, include a
   __control flow statement__ that __terminates__ the `while` loop.

6. Uncomment the accompanying `print()` call and `assert` statement, run
   your code, and review your work.

   ```python
    # First Ypsilanti nested list in stations (return its index value)
    [
        '145371', 'Roundtree Place', None, 'public', '24 hours daily', None, 'Ypsilanti', '48197', '2539 Ellsworth Rd', None, 'Electrify America', 'CHADEMO, J1772COMBO', '6', None, None, None, None, '2022-09-07'
    ]
   ```

### 5.3 `while` loop `else` condition

The `while` loop includes a built-in `else` condition that you can use to execute one or more
statements after the loop terminates.

```python
i = 0
while i < 5:
    print('I want an EV.')
    i += 1 # increment
else:
    print('Enough said. We believe you.')
```

### 5.4 `while` loop and conditional statements

You can employ conditional statements inside a `while` loop in order to determine the control flow
of each iteration. In the following example the modulus (`%`) operator is used to identify even and
odd numbers between 0 and 10.

:bulb: use the modulus operator to return the remainder after one number is divided by another. If
the remainder equals zero the number evaluated is an even number.

```python
i = 0
while i < 10:
    if i % 2 == 0:
        print(f"{i} is an even number.")
    else:
        print(f"{i} is an odd number.")
    i += 1 # increment
```

You can also count in reverse ("countdown") by decrementing the counter `i` using the subtraction
assignment (`-=`) operator:

```python
i = 10
while i >= 0:
    if i % 2 == 0:
        print(f"{i} is an even number.")
    else:
        print(f"{i} is an odd number.")
    i -= 1 # decrement
```

### 5.5 `while` loop and the `range` type

You can employ a `while` loop in conjunction with the `range` type to loop over a sequence of
numbers. In the example below the `while` loop iterates over the sequence `0, 2, 4, 6, 8` provided
by `range(0, 10, 2)`.

:exclamation: note that `i` is incremented by 2 not 1.

```python
i = 0
while i in range(0, 10, 2):
    print(f"{i} is an even number.")
    i += 2 # increment by 2
```

### 5.6 Challenge 02

__Task__: The "ev_connector_types" value is, in certain cases, a list masquerading as a string
(e.g., `'CHADEMO, J1772COMBO'`). Convert this value to a list for all stations in the `stations`
list.

1. Uncomment the partially implemented `while` loop.

2. Pass arguments to the `range` type to return an instance of `range` that comprises a sequence of
   numbers sync'd to the length of the `stations` list.

3. Inside the `while` loop call the appropriate string method to convert each station's
   "ev_connector_type" string value to a list:

   `'CHADEMO, J1772COMBO'` -> `['CHADEMO', 'J1772COMBO']`

   Assign the new list "back" to the "ev_connector_types" element using subscript operator chaining.

   :exclamation: Do not call `get_station_element()` to access the "ev_connector_types" value.
   Instead lookup the index value of the "ev_connector_types" header element and use it in a chain
   of subscript operators to access the nested list element.

4. Inside the `while` loop block increment the variable `i` by one (`1`).

   :exclamation: In order to avoid triggering an infinite loop you _must_ increment the counter `i`
   inside the loop.

5. Uncomment `print()` and check your work.

### 5.7 Built-in `input()` function and the while loop

The built-in `input()` function accepts user-supplied strings from the command prompt. It is often
positioned inside a `while` loop in order to process user input. The pattern is illustrated in the
following example.

In the code below, the built-in function `input()` prompts the user for a street name. The
function call is placed inside a `while` loop in order to query the user continuously until a
street name found in the `streets` list is provided.

The `if` statement performs a _case sensitive_ membership check. If a match is obtained the boolean
`True` is assigned to the variable `is_found`. If an exact match is not obtained (e.g., Ann Street
`!=` W Ann St), the `else` statement block provides for _case insensitive_ partial matching (e.g.,
"Ann" `in` "W Ann St). If a partial match is obtained, the boolean `True` is assigned to the
variable `is_found`.

The `break` statement is then employed to exit the `streets` loop.

Thereafter, if `is_found` resolves to `True` the built-in function `print()` is called and passed
the "SUCCESS" string. A second `break` statement is added to exit the `while` loop.  If `is_found`
remains `False` the built-in function `print()` is called and passed the "FAIL" string. The `while`
loop proceeds to the next iteration of the loop and the user is again prompted to provide a street
name.

:bulb: The variable `is_found` is key to the design of the example `while` loop. The conditional
logic inside the `while` loop requires a way to signal that a match has been obtained and that both
the inner `streets` loop and outer `while` loop can be exited. The `is_found` _truth value test_
(i.e., `if is_found:`) also eliminates the need to duplicate "SUCCESS" calls to the built-in
function `print()`. This is an illustration of the
[DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) in action.

```python
STREETS = (
    'Ann Arbor-Saline Rd',
    'Auto Mall Dr',
    ...
    'W Washington',
    'W William St'
    )

def main():
    msgs = (
        "SUCCESS: One or more EV charging stations can be found on the provided street.",
        "FAIL: No EV charging stations found on provided street. Provide a different street name.",
    )

    while True:
        is_found = False
        entry = input("\nProvide street name: ")

        if entry in STREETS:
            is_found = True  # exact match obtained
        else:
            for street in STREETS:
                if entry.lower() in street.lower():
                    is_found = True
                    break  # partial match obtained, exit loop

        if is_found:
            print(f"\n{msgs[0]}")
            break  # exit while loop
        print(f"\n{msgs[1]}")

if __name__ == "__main__":
    main()
```

## 6.0 Data handling: truth value testing

In Python every object can be tested for its
[_truth value_](https://docs.python.org/3/library/stdtypes.html#truth-value-testing). You can check
an object's truth value in an `if` or `while` statement or as an operand (i.e., the value the
operator operates on) in an `and`, `or`, or `not` Boolean operation. A value that evaluates to
`True` is considered __truthy__ while a value that evaluates to `False` is considered __falsy__.

For SI 506 the following values are considered "truthy" or "falsy":

| Type                                       | Value     | Truth value |
|:-------------------------------------------|:----------|:------------|
| Nonetype                                   | `None`    | falsy       |
| numeric (`int`, `float`)                   | non-zero  | truthy      |
| numeric (`int`, `float`)                   | 0, 0.0    | falsy       |
| boolean                                    | `True`    | truthy      |
| boolean                                    | `False`   | falsy       |
| sequence (`list`, `range`, `tuple`, `str`) | non-empty | truthy      |
| sequence (`list`, `range`, `tuple`, `str`) | empty     | falsy       |
| associative array (`dict`)                 | non-empty | truthy      |
| associative array  (`dict`)                | empty     | falsy       |

The following examples demonstrates testing an object's truth value utilizing the built-in function
`bool()` which accepts an object and returns either `True` or `False` per the standard truth value
testing rules:

```python
def evaluate_truth_value(val):
    return bool(val) # check the object's truth value

connectors = None
truth_value = evaluate_truth_value(connectors)  # False
print(f"\n3.0.1 Truth value of None = {truth_value}")

connectors = ""
truth_value = evaluate_truth_value(connectors)  # False
print(f"\n3.0.2 Truth value of empty string = {truth_value}")

connectors = "J1772"
truth_value = evaluate_truth_value(connectors)  # True
print(f"\n3.0.3 Truth value of J1772 = {truth_value}")

connectors = []
truth_value = evaluate_truth_value(connectors)  # False
print(f"\n3.0.4 Truth value of empty list = {truth_value}")

connectors = ["CHADEMO", "J1772COMBO"]
truth_value = evaluate_truth_value(connectors)  # True
print(f"\n3.0.5 Truth value of list = {truth_value}")
```

### 6.1 Working with `None` or blank values

Note that some elements in `stations` utilize `None` to represent the absence of a value. Recall,
that `None` represents a missing or unknown value. The presence of `None` or a blank (`""`)
string in a data set is problematic. Many object methods and built-in functions are _not_ designed
to operate on `None` or blank. For example, calling the `str.split()` method on `None` or passing
`None` to the built-in `int()` function will trigger a runtime exception (`AttributeError` and
`TypeError` respectively).

Given the presence of missing data in the EV station data set (expressed by the use of `None`), a
function that could evaluate the truth value of _any_ element in the data set _prior_ to operating
on it in some way would prove useful.

Consider the design of the function `has_value()`. The function leverages the existing capabilities
provided by the functions `get_element()` and `evaluate_truth_value()` by _delegating_ to each a
specific task:

1. `get_element()`: retrieve a specified element.
2. `evaluate_truth_value()`: evaluate the truth value of the element provided by `get_element()`.

Note that the function `has_value()` is provisioned with parameters that are required by the
function `get_element()`. When the function `has_value()` is called the caller is required to
provide the three arguments needed by `get_element()` to do its job.

```python
def has_value(station, headers, header):
    element = get_element(station, headers, header)
    truth_value = evaluate_truth_value(element)
    return truth_value
```

The `has_value()` function block can be reduced to a single line of code by passing the function
`get_element()` as an argument to the function `evaluate_truth_value()`.

```python
def has_value(station, headers, header):
    return evaluate_truth_value(get_element(station, headers, header))
```

An alternative approach is to evaluate the truth value of the element returned by `get_element()`
using an `if` statement. Note the simplicity of the conditional statement. If the conditional
statement evaluates the truth value of `element` as `truthy` the function returns `True` to the
caller; otherwise `False` is returned.

```python
def has_value(station, headers, header):
    element = get_element(station, headers, header)
    if element:  # truth value test
        return True
    return False  # Required otherwise None is returned
```

:exclamation: Do not assume that the conditional statement `if element:` is equivalent to
`if element is not None:`. The former evaluates the truth value of `element` while the latter
evaluates the _identity_ of `element`. If `element` is an empty list, the conditional statement `if element is not None:` will fail to detect the _falsy_ nature of the list.

You can simplify the alternative implementation of `has_value()` by dispensing with the variable assignment in favor of embedding the `get_element()` function call in the `if` statement. The
function `has_value()` is then reduced to a single line of code.

```python
def has_value(station, headers, header):
    if get_element(station, headers, header):
        return True
    return False  # Required otherwise None is returned
```

:bulb: The variants above illustrate application of the [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle since the function `has_value()` eschews re-implementing
functionality in favor of leveraging existing functions to perform its designated task.

With `has_value()` implemented, we can call it any time we need to evaluate the truth value of a
particular element in the data set.

For example, if you need to check how many stations specify a facility type you can utilize a `for`
loop to accumulate a count of station "facility_type" values that are neither `None` or blank.
Inside the loop block add a conditional statement that evaluates the return value of the function `has_value()`. Pass it the arguments required to evaluate each station's "facility_type" element and increment `count` by `1` whenever the return value evaluates to `True`.

```python
count = 0
for station in stations:
    facility_type = get_element(station, headers, "facility_type")
    if facility_type:  # truth value test
        count += 1
```

Or implement the loop this way:

```python
count = 0
for station in stations:
    if has_value(station, headers, "facility_type"):
        count += 1
```

### 6.2 Handling ties when counting

Below is another example of how to avoid triggering runtime exceptions when passing (inadvertantly)
`None` or a blank value as an argument to a function or object method not designed to handle such
values.

Let's say you need to return station locations featuring the highest number of Level 2 EVSE ports.
You should assume that multiple locations could meet this requirement. In other words, you need to
account for the possibility that ties exist in the data. You could adopt the following approach to identifying the station(s) with the highest number of Level 2 EVSEs:

```python
most_evse = []  # list accommodates multiple stations
evse_count = 0
for station in stations:
    num = int(get_element(station, headers, "ev_level2_evse_num"))
    if num > evse_count:
        evse_count = num  # new
        most_evse.clear()  # clear previous leader(s)
        most_evse.append(station)  # new leader
    elif num == evse_count:
        most_evse.append(station)  # tie
    else:
        continue  # else condition explicit but optional
```

The following operations are performed during each iteration of the loop:

1. The element "ev_level2_evse_num" is retrieved from the current station and assigned to the
   variable `num`.

2. The `int()` function is called to convert `num` to an integer.

3. The integer `num` is compared to the previous `evse_count` value.

4. If `num` is greater than `evse_count` a new "leader" has been detected. The `evse_count` is
   assigned `num` and any previous stations appended to the accumulator `most_evse` list are removed
   by calling the `list.clear()` method. The new "leader" is then appended to the `most_evse` list.

5. If `num` is equal to the previous `evse_count` value a tie has been detected. In this case, the
   current station is appended to the `most_evse` list joining the previous leader(s).

6. If `num` is less than the previous `evse_count` value the looping operaton proceeds to the next
   iteration.

This execution flow works well until you encounter a station with a Level 2 EVSE value that is
`None` or blank. In such cases, calling the built-in function `int()` function will trigger a
runtime exception:

1. "ev_level2_evse_num" is `None`

   ```commandline
   TypeError: int() argument must be a string, a bytes-like object or a real number, not 'NoneType'
   ```

2. "ev_level2_evse_num" is blank (`""`)

   ```commandline
   TypeError: '>' not supported between instances of 'str' and 'int'
   ```

You can avoid triggering a runtime exception by checking the truth value of the `element` returned
by calling `get_element()` _prior_ to converting the value to an integer. However, this approach
requires that you __invert__ the truth value of `element` (i.e., `not False` = `True`) using the
logical operator `not` to ensure that _falsy_ elements are skipped.

```python
most_evse = []  # list accommodates multiple stations
evse_count = 0
for station in stations:
    element = get_element(station, headers, "ev_level2_evse_num")

    if not element:
        continue  # skip; not False = True

    num = int(element)
    if num > evse_count:
        evse_count = num  # new
        most_evse.clear()  # clear previous leader(s)
        most_evse.append(station)  # new leader
    elif num == evse_count:
        most_evse.append(station)  # tie
    else:
        continue  # else condition explicit but optional
```

:bulb: In a future lecture Team 506 will introduce you to `try-except` statements for catching and
handling exceptions. For now, the conditional block `if not element: continue` provides a way to
avoid triggering a runtime exception that would otherwise occur if `None` or a blank string were
passed to the built-in `int()` function.

## 7.0 Compound conditional statements (comparing values using logical operators)

Recall that an `if` statement returns either `True` or `False`. You can combine conditions and
compare values in a single `if` statement using the logical operators `and` (conjunction), `or` (disjunction) and `not` (negation), either singly or together in various combinations, as occurs in Boolean algebra.

### 7.1 Logical `and` operator

The logical `and` operator combines two or more conditions in a single boolean expression. _All_
conditions comprising the expression _must_ evaluate to `True` for the expression to evaluates to
`True`; otherwise the expression evaluates to `False`.

```commandline
< condition > and < condition > [and ...]

>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False
```

If you need to return a list of stations that provide between two (`2`) and four (`4`) Level2 EVSE
ports (inclusive), you can employ the logical operator `and` to combine the two conditions
required to evaluate each "ev_level2_evse_num" element correctly:

* Evaluate the truth value (to filter out `None`).
* Evaluate that the number of Level 2 EVSE ports is between `2` and `4` (inclusive).

```python
station_evse = []
for station in stations:
    element = get_element(station, headers, "ev_level2_evse_num")
    if element and int(element) >= 2 and int(element) <= 4:
        station_evse.append(f"{station[1]}: Level2 EVSE = {element}")
```

Better yet, you can simplify the `for` loop's conditional statement by
locating the expression `int(element)` between the two comparison operators.
Doing so eliminates the need to call `int()` twice.

```python
station_evse = []
for station in stations:
    element = get_element(station, headers, "ev_level2_evse_num")
    if element and 2 <= int(element) <= 4:
        station_evse.append(f"{station[1]}: Level2 EVSE = {element}")
```

### 7.2 Challenge 03

__Task__. The U-M campus hosts a number of EV charging stations. Employ a `for` loop and a compound conditional statement to access the __U-M station__ located on __Greene Street__.

1. Look up the index value of the `headers` element "station_name" by calling the appropriate list
   method. Assign the integer returned to the variable named `name_idx`.

2. Look up the index value of the `headers` element "street_address" by calling the appropriate list
   method. Assign the integer returned to the variable named `street_idx`.

3. Replace the `pass` statement in the loop block with a _compound_ `if` statement that filters on
   the following conditions:

   * "U-M" owned stations (all U-M station names commence with the substring "U-M").
   * "Greene St" location (treat the string as a substring of a longer string)

4. Add each nested charging station list that satisfies _both_ conditions to the `um_stations` list.

5. Uncomment `print()` and `pp.pprint()` and check your work.

### 7.3 Logical `or` operator

The logical `or` operator combines two or more conditions in a single boolean expression. If _any_
condition comprising the expression evaluates to `True` the expression evaluates to `True`;
otherwise the expression evaluates to `False`.

```commandline
< condition > or < condition > [or ...]

>>> True or True
True
>>> True or False
True
>>> False or True
True
>>> False or False
False
```

In the example below, we can accumulate stations owned by the Ann Arbor Downtown Development
Authority (A2DDA) by employing the logical `or` operator:

```python
a2dda_stations = []
for station in stations:
    name = station[headers.index("station_name")].strip()
    if name.startswith("A2DDA") or name.startswith("Ann Arbor Downtown Development Authority"):
        a2dda_stations.append(station[headers.index("station_name")])
```

### 7.4 Logical `not` operator

The logical `not` operator reverses or negates a boolean expression. If the boolean expression
evaluates to `True` the inclusion of the logical `not` operator inverts or reverses the value to
`False`; likewise if the boolean expression evaluates to `False` the inclusion of the logical `not` operator inverts or reverses the value to `True`.

:exclamation: note that the logical `not` operator reverses only the condition to which it is
paired. Reversing multiple conditions requires grouping the conditions with parentheses as
described below in the next section.

```commandline
not < condition >

>>> not True
False
>>> not True and True
False
>>> not True or True
True
>>> not True and False
False
>>> not True or False
False
>>> not False
True
>>> not False and True
True
>>> not False or True
True
>>> not False or False
True
```

Most of the stations in the `stations` list are part of the ChargePoint network. If you
need to accumulate a count of stations that are either non-networked or a member of another
network you can employ the logical `not` operator to _reverse_ the booelan value
returned by the expression contained in the following `if` statement.

```python
ev_network_idx = headers.index("ev_network")

# Count non ChargePoint network EV charging stations
station_count = 0
i = 0  # reset
for i in range(len(stations)):
    if not stations[i][ev_network_idx].strip().lower() == "chargepoint network":
        station_count += 1
```

:bulb: One could argue that employing the comparison operator not equal (`!=`) instead of the
logical `not` operator provides a more readable expression:

```python
stations[i][ev_network_idx] != 'ChargePoint Network'
```

### 7.5 Grouping related expressions

You can employ parentheses `()` to group related conditions that comprise a boolean expression.

:exclamation: Logical operator precedence is `not`, then `and`, then `or`.

```commandline
>>> not True and True or False
False
>>> not False and True or False
True
not (False and False) or False
True
```

Pairing the logical `not` operator with a group of conditions will reverse the group result but not
conditions outside the group.

```commandline
>>> not (False and False) or False
True
>>> not False and (False or False)
False
>>> not True or (True or False)
True
```

If you need to return a list of stations located in a designated "parking garage", "parking lot", or
"pay garage" you could implement the following `while` loop:

```python
parking_facilities = []
i = 0
while i < len(stations):
    facility_type = stations[i][facility_type_idx]
    if facility_type and (
        facility_type.strip().lower() == "parking garage"
        or facility_type.strip().lower() == "parking lot"
        or facility_type.strip().lower() == "pay garage"
    ):
        parking_facilities.append(stations[i])
    i += 1
```

:exclamation: Note the use of parentheses `(..)` to group the `or` conditions. This ensures that the condition are evaluated in the correct order.

:exclamation: Note too how the `or` conditions are formatted. Each condition _must_ be fully
described. You will trigger a runtime exception if you group the `or` conditions as follows:

```python
if facility_type and (facility_type.lower() == "parking garage" or "parking lot" or "pay garage"):
```

If there is a requirement to restrict the results to __private__ parking facilities only, the
`if` statement can be amended by adding an additional condition using the logical `and`
operator.

```python
access_code_idx = headers.index("access_code")
parking_facilities = []
i = 0
while i < len(stations):
    facility_type = stations[i][facility_type_idx]
    access_code = stations[i][access_code_idx]
    if (
        facility_type
        and (
            facility_type.strip().lower() == "parking garage"
            or facility_type.strip().lower() == "parking lot"
            or facility_type.strip().lower() == "pay garage"
        )
        and access_code.strip().lower() == "private"
    ):
        parking_facilities.append(stations[i])
    i += 1
```

### 7.6 Challenge 04

__Task__. Create a list of all Ann Arbor Downtown Development Authority (A2DDA) stations located on
either Forest Ave __or__ Maynard St.

1. Inside the loop block call the function `get_element()` as needed to retrieve each
   station's "station_name" and "street address". Assign the values to the variables `name` and
   `street` respectively.

2. Next, implement a compound conditional statement that enforces the following conditions:

   1. Station name is either "A2DDA" or "Ann Arbor Downtown Development Authority", and
   2. Station is located on either Forest Ave or Maynard St.

3. If the compound conditional statement evaluates to `True`, append a formatted string
   literal (f-string) to `a2dda_stations` formatted as follows:

   ```python
   f"{name} {street}"
   ```

4. Uncomment `print()` and check your work.
