# SI 506: Iteration and Control Flow, Part I

## Topics

1. Reference
2. Lecture data
3. Iteration and control flow
   1. Nested lists
   2. Definite iteration: `for` loop
   3. The `if` statement
   4. Challenges
      1. Challenge 01
      2. Challenge 02
4. The accumulator pattern
   1. Challenges
      1. Challenge 03
      2. Challenge 04
   2. Accumulating counts
   3. Challenges
      1. Challenge 05
5. `if-else` conditions
   1. Challenges
      1. Challenge 06
      2. Challenge 07
6. `if-elif-else` conditions
   1. Challenges
      1. Challenge 08
7. Looping with the `range` type
   1. `range` behaviors
   2. The `for` loop and `range`
   3. Employing `range` to replace list elements
   4. Subscript operators chaining
   5. Challenges
      1. Challenge 09
      2. Challenge 10
      3. Challenge 11

## 1.0 Reference

Bookmark the following
[w3schools](https://www.w3schools.com/python/default.asp) Python pages and/or have them open in a
set of browser tabs both during class and while working on this week's problem set:

* ["Python Built-in Functions"](https://www.w3schools.com/python/python_ref_functions.asp)
* ["Python Operators"](https://www.w3schools.com/python/python_operators.asp)
* ["Python List Methods"](https://www.w3schools.com/python/python_ref_list.asp)
* ["Python String Methods"](https://www.w3schools.com/python/python_ref_string.asp)
* ["Python Tuple Methods"](https://www.w3schools.com/python/python_ref_tuple.asp).

## 2.0 Lecture data

This week's lecture data is drawn from the US Dept of Energy's
[Alternative Fuels Data Center](https://afdc.energy.gov/) information on model year 2023
[electric vehicles](https://afdc.energy.gov/vehicles/search/download.pdf?year=2023) (EVs).

:bulb: Each EV is represented by a nested list in `E_VEHICLES`. In addition, the column headers that
describe each EV's attributes are stored in the first nested list.

:bulb: The abbreviation "mpge" in the string `fuel_economy_mpge` is short-hand for
_miles per gallon of gasoline-equivalent_.

## 3.0 Iteration and control flow

This week we focus on _iteration_ (i.e., accessing sequence elements employing loops) and
_control flow_ (i.e., the order in which a program or script executes). You will learn how to
iterate or loop over a sequence (`list`, `range`, `str`, `tuple`) using a `for` loop. Next week you
will learn how to use the `while` loop.

You will also learn how to apply conditional statements in order to determine which computations
your code must perform. Conditional statements can be placed inside the body of a `for` loop in
order to act as data filters or terminate a looping operation if a particular condition has been
satisfied.

Conditional statements employ a variety of operators. As noted previously, Python operators are
organized into [groups](https://www.w3schools.com/python/python_operators.asp). We’ve touched on
arithmetic operators and assignment operators. Starting this week you will begin using other
operators when writing conditional statements, especially comparison, identity, and membership
operators, and logical operators such as `and`, `or`, and `not`.

### 3.1 Nested lists

The Python _sequence_ is a container data type that holds objects that can be accessed individually
or in groups by their position. Both strings and lists are sequences. The `str` data type comprises
an ordered collection of _immutable_ characters, the `list` data type comprises an ordered
collection of _mutable_ elements, and the `tuple` data type comprises an ordered collection of
_immutable_ items.

The lists and tuples that you've encountered thus far have consisted of strings and/or numbers.
In the example below, each element in the `vehicles` list represents an electric vehicle (EV).
Each string contains a set of attributes (automaker, model, model year, range in mpg, etc.) that are
delineated by use of a _comma_ and _space_ as a separator.

```python
# EV attributes: make, model, vehicle type, drivetrain, fuel economy mpge,
# range mi, battery capacity kwh, seats, base msrp

vehicles = [
   "Tesla, Model 3 RWD, Sedan/Wagon, RWD, 132, 272, 60, 5, $46,990",
   "Porsche, Taycan GTS Sport Turismo, Sedan/Wagon, AWD, 80, 233, 109, 4, $86,700",
   "Kia, Niro Electric, Sedan/Wagon, FWD, 113, 253, 64, 5, $39,900",
   "Lucid, Air G Touring XR AWD, Sedan/Wagon, AWD, 131, 516, 120, 5, $87,400",
   "Toyota, bZ4X AWD, SUV, AWD, 104, 228, 72, 5, $44,080",
]
```

Accessing individual vehicle data in the list of strings requires splitting each string on the
comma and space (`", "`) in order to access the desired vehicle attribute(s) by its index:

```python
model = vehicles[0].split(", ")[1]  # Model 3 RWD
```

The above operation suggests that that vehicle data could be represented as a list of lists, with
each "inner" list element holding a distinct piece of information. Since lists (and tuples) can
reference more complex data types, we should consider representing each EV as a "nested" list rather
than a string.

:bulb: The comments `# fmt: off` and `# fmt: on` are used to disable/enable the Ruff formatter. In
this case the goal is to permit the line length of each nested list to exceed `100` characters.

```python
# fmt: off
vehicles = [
   ["Tesla", "Model 3 RWD", "Sedan/Wagon", "RWD", "132", "272", "60", "5", "$46,990"],
   ["Porsche", "Taycan GTS Sport Turismo", "Sedan/Wagon", "AWD", "80", "233", "109", "4", "$86,700"],
   ["Kia", "Niro Electric", "Sedan/Wagon", "FWD", "113", "253", "64", "5", "$39,900"],
   ["Lucid", "Air G Touring XR AWD", "Sedan/Wagon", "AWD", "131", "516", "120", "5", "$87,400"],
   ["Toyota", "bZ4X AWD", "SUV", "AWD", "104", "228", "72", "5", "$44,080"]
]
# fmt: on
```

Accessing the first element's "model" element involves chaining the index positions.

```python
model = vehicles[0][1] # Model 3 RWD
```

### 3.2 Definite iteration: the `for` loop

Indexing and slicing sequence elements by position is standard operating procedure for Python
programmers. However, if you need to interact with _all_ members of a sequence indexing and/or
slicing your way to success could prove tedious and inefficient. Python provides a ready solution
to this challenge in the guise of the `for` loop.

Writing a `for` loop simplifies sequence traversal. You can loop over the entirety (or a portion)
of a sequence confident that the loop will terminate automatically once the
the last character, element, or item in the sequence (or subset of the sequence) is reached.  This
process is known more generally as __definite iteration__.

The keywords `for` and `in` comprise the basic syntax of the `for` loop:

```python
for < element > in < sequence >:
    # indented block
    < statement A >
    < statement B >
    # ...
```

Note that the `for` loop statement is terminated by a trailing colon (`:`). The colon indicates the
start of the loop's code block. The statement(s) that comprise the loop's code block _must_ be
indented four (`4`) spaces. The statements are _local_ to the loop and are only executed when the
loop is run.

In the following example, each element in `E_VEHICLES` is assigned the "loop" variable `vehicle`.
During each iteration of the loop the `vehicle` element is passed to the built-in `print()`
function. After the last `vehicle` element is printed the loop terminates.

```python
for vehicle in E_VEHICLES:
   print(vehicle)  # indented block (includes "headers" element)
```

:exclamation: Failure to employ Python's indention rules can lead to unexpected computations and/or
trigger an `IndentionError`.

You can limit the number of loop iterations by targeting a subset of a sequence. In the following
example, slicing is employed to restrict the number of loop iterations to the second, third, and
fourth elements in `E_VEHICLES`:

```python
for vehicle in E_VEHICLES[1:4]:
   print(vehicle)  # indented block (excludes "headers" element)
```

### 3.3 The `if` statement

Looping just to loop is not all that useful. Data is compiled (usually) in the hope that later
statistical analysis will reveal otherwise hidden patterns in the data set. Conditional logic can be
embedded in a `for` loop block in order to interact with a sequence's elements in more meaningful
ways.

A Python conditional statement evaluates to either `True` or `False`. Conditional statements placed
inside a `for` loop block determine which computations, if any, are to be performed during each
iteration of the loop.  More generally, conditional statements help determine a computer
program's _control flow_ or the order in which individual statements are executed.

The keyword `if` comprises the basic syntax of a conditional statement:

```python
if < condition >:
    # indented block
    < statement C >
    < statement D >
    # ...
```

Like the `for` loop the `if` statement is terminated with a trailing colon (`:`). The colon
indicates the start of the conditional statement's code block. The statement(s) that comprise
the `if` statement's code block _must_ be indented four (4) spaces. The statements are _local_ to
the `if statement` and are _only_ executed if the statement condition returns `True`.

Below is a second example in which `E_VEHICLES` elements are passed to the built-in `print()`
function. But in this case, the `if` statement filters on the "maker" element and only calls
`print()` if the vehicle manufacturer is named Kia.

```python
for vehicle in E_VEHICLES[1:]:
if vehicle[0].find("Kia") > -1:
   print(vehicle)
```

:bulb: `str.find()` returns `-1` if no match is obtained; otherwise the method call returns the
index of the first occurence of the passed in substring.

You can also employ the [membership operator](https://www.w3schools.com/python/python_operators.asp)
`in` to evaluate whether a substring is present in a string.

```python
for vehicle in E_VEHICLES[1:]:
   if "volkswagen" in vehicle[0].lower():
      print(vehicle)
```

The opposite condition can also be evaluated. If you needed to identify and print all EVs in
`E_VEHICLES` produced by automakers other than Volkswagen you could employ the `not in` membership
operator.

```python
for vehicle in E_VEHICLES[1:]:
   if "volkswagen" not in vehicle[0].lower():
      print(vehicle)
```

:bulb: Use of `str.lower()` renders the `if` statement _case-insentive_ ensuring that possible
variations in the manufacturer name (e.g., "Volkswagen", "volkswagen", "VOLKSWAGEN"), will not result
in skipping otherwise valid matches. This is an example of "defensive" programming. When working
with string data never assume that the data is "clean" (i.e., uniform and consistent). Note that
there will be occasions when you will need to perform _case-sensitive_ string matching.

### 3.4 Challenges

#### 3.4.1 Challenge 01

__Task__: Access the "headers" and "vehicle" nested lists and assign to variables. Use the headers
to _look up_ corresponding vehicle values.

:bulb: Note that the first nested list in `E_VEHICLES` represents the column header values.

```python
E_VEHICLES = [
    ["make", "model", "type", "drivetrain", "fuel_ec_mpge", "range_mi", "battery_kwh", "seats", "base_msrp"],
    ["Tesla", "Model 3 RWD", "Sedan/Wagon", "RWD", "132", "272", "60", "5", "$46,990"],
    ...,
]
```

1. In `main()`, employ indexing to assign the `E_VEHICLES` "headers" element to a variable named
   `headers`.

2. Call the `headers` `list.index()` method and pass to it the argument "model". Assign the return
   value to the variable `model_idx`.

   :bulb: You can leverage the `headers` list to _look up_ the index of a column header in order
   to access the corresponding value in a vehicle list.

3. Employ slicing to assign the remainder of the `E_VEHICLES` nested list elements to a variable
   named `vehicles`.

4. Access the fourth (`4th`) _nested_ vehicle list in `vehicles` by its index. Assign the list to a
   variable named `lucid`.

5. Call the appropriate list method to look up the "range_mi" index in `headers`. Assign the integer
   returned to a variable named `range_mi_idx`.

6. Access the `lucid` "range_mi" element using the `range_mi_idx` value. Assign the element accessed
   to the variable named `lucid_range_mi`.

7. Uncomment the accompanying `print()` function call and `assert` statement, run your code, and
   check your work.

#### 3.4.2 Challenge 02

__Task__: Implement a function that returns a vehicle's make and model as a formatted string.

1. Implement the function named `get_make_model()`. The function is provisioned with a single
   parameter:

   * `vehicle` (`list`). List representation of a vehicle.

   __Requirements__

   1. Design the function to access the `vehicle` "make" and "model" elements.

   2. Employ a __formatted string literal__ (f-string) that combines the "make" and "model"
      elements into a single formatted string. Format the string as follows:

      ```python
      "< vehicle make >< space >< vehicle model >"
      ```

   3. After constructing the new string return it to the caller.

      :bulb: The function can be implemented with a single line of code.

2. Return to `main()`. Call the function `get_make_model()`.  Pass it the __second to last__ nested
   list in the `vehicles` list. Assign the return value to the variable named `make_model`.

3. Uncomment the accompanying call to `print()` and the `assert` statement. Run your code and
   confirm that you have returned the correct string.

## 4.0 The accumulator pattern

One common programming “pattern” is to traverse a sequence (e.g., a `str`, `list`, or `tuple`),
_accumulating_ a value during each iteration of the loop and assigning it to another sequence.

In the example below, the empty list named `teslas` serves as an accumulater. The list will store
lists representing Tesla electric vehicles "accumulated" as a result of the looping operation.

```python
teslas = []
for vehicle in vehicles:
   if vehicle[0].lower().find("tesla") > -1:
      teslas.append(vehicle)
```

Another variant of the accumulator pattern is to initialize an accumulator value and assign it a
default value that is updated by a `for` loop whenever a certain loop condition is satisfied.

In the example below, two accumulator values are utilized in order to find the electric vehicle
featuring the greatest range in miles. When looping over `vehicles` the variable `max_range`
is assigned an updated value if a vehicle's range (converted from a string to an integer using the
built-in function `int()`) is greater than `max_range`. Likewise, the variable `ev_max_range`
is assigned a new value whenever the `if` the condition evaluates to `True`. When the loop
terminates, the nested vehicle list containing the max range value will have been assigned to
`ev_max_range`.

:exclamation: The looping opertation below _does not_ handle ties (i.e., multiple vehicles featuring
the same max range) You will learn how to handles ties later in the course.

```python
ev_max_range = None
max_range = 0
for vehicle in vehicles:
   # vehicle_range = int(vehicle[5])  # cast str to int
   vehicle_range = int(vehicle[headers.index("range_mi")])  # lookup index
   if vehicle_range > max_range:
      ev_max_range = get_make_model(vehicle)  # call function
      max_range = vehicle_range
```

### 4.1 Challenges

#### 4.1.1 Challenge 03

__Task__: Implement a function that returns a list of electric vehicles filtered on a given
automaker.

1. Implement the function named `get_vehicles()`. The function is provisioned with two parameters:

   * `vehicles` (`list`): List of electric vehicles.
   * `automaker` (`str`): Automaker name.

   __Requirements__

   1. Inside the function block, implement a `for` loop to iterate over the passed in `vehicles`
      list.

   2. Inside the loop block, add a conditional `if` statement that evaluates whether or not a
      vehicle is produced by the passed in `automaker`. If the conditional statement evaluates to
      `True`, append the nested list representing the vehicle to the accumulator list named `autos`.

      :exclamation: Perform a __case insensitive__ comparison between the two strings
      (call `str.lower()`).

   3. Return `autos` to the caller.

2. Return to the `main()` function.

3. Call the function `get_vehicles()` and pass it the arguments required to return a list of
   __Rivian__ electric vehicles. Assign the return value to a variable named `rivian_models`.

4. Uncomment the accompanying `print()` function call, run your code, and check your work.

#### 4.1.3 Challenge 04

__Task__: Identify the EV with the shortest battery range.

1. In `main()` review the `ev_min_range` variable assignment. The list will be used to store _both_
   the electric vehicle name and its battery range value.

   ```python
   ev_min_range = [< vehicle make & model >, < vehicle battery range >]
   ```

   :bulb: `None` and `10000` are _placeholder_ elements that _must_ be replaced. The high starting
   value ensures that the first vehicle encountered will be assigned to `ev_min_range`. Whether the
   first vehicle encountered retains its place as the electric vehicle with the shortest range
   depends on the values of subsequent vehicles.

2. Loop over `vehicles`. Inside the `for` loop, call `headers.index()` to look up the "range_mi"
   index. Assign the integer to a variable named `range_mi_idx`.

3. Use `range_mi_idx` to access the vehicle "range_mi" value. Convert the string to an integer by
   passing it directly to the built-in function `int()`. Assign the return value to a variable
   named `vehicle_range`.

   :exclamation: Avoid using `range` as a variable name. Doing so "shadows" the `range` type name
   and will trigger a runtime exception when instantiating an instance of the `range` type later
   in the lesson.

4. Implement an `if` statement that evaluates whether or not the "current" `vehicle_range` value
   __is less__ than the "previous" battery range value stored in the list `ev_min_range`.

   :bulb: Access the `ev_min_range` battery range element by its index.

5. Inside the `if` block assign the vehicle __make and model__ as the first (`1st`) element and
   `vehicle_range` as the second (`2nd`) element of `ev_min_range`. Doing so will ensure that the
   list elements are refreshed whenever a vehicle with a shorter range is located.

   :bulb: Call `get_make_model()` to retrieve the make and model of a vehicle.

6. Uncomment the accompanying call to `print()` and the `assert` statement. Run your code and
   confirm that `ev_min_range` contains the correct elements.

### 4.2 Accumulating counts

The built-in `len()` function provides the overall length or size of a sequence. But if you
want to return a count of a subset of a sequence in which slicing cannot be used, then consider
using a "counter" variable to hold a rolling count of the elements that satisfy a
given condition.

In the following example a count of vehicles manufactured by BMW is accumulated. A
default value of zero (`0`) is assigned to the `bmw_count` variable. The variable is utilized to
accumulate a count of the number of nested lists that represent EVs produced by BMW.

:bulb: Note use of the "assignment addition" operator `+=` to _increment_ the count. The expression
`bmw_count += 1` is the equivalent to `bmw_count = bmw_count + 1`, an example of Python
"syntatic sugar" that I encourage you to use.

```python
bmw_count = 0
for vehicle in vehicles:
   if "bmw" in vehicle[0].lower():
      bmw_count += 1  # assignment addition equivalent to bmw_count = bmw_count + 1
```

:bulb You can also perform "assignment subtraction using the `-=` operator to _decrement_ a count.

### 4.3 Challenges

#### 4.3.1 Challenge 05

__Task__: Implement a function that returns a count of the number of EVs in `vehicles` with a
battery range greater than or equal to 250 miles.

1. Create a function named `count_vehicles_by_range()`. The function is provisioned with three
   parameters:

   * `vehicles` (`list`): Nested lists that represent individual vehicles.
   * `headers` (`list`): List of vehicle column names.
   * `range_mi` (`int`): Battery range in miles.

   __Requirements__

   1. Loop over the passed in `vehicles` list. Inside the loop block implement a conditional `if`
      that can evaluate whether or not a vehicle's battery range is _greater than or equal to_ the
      passed in `range_mi` value.

      :bulb: Conditional statements can compare two values using the following comparison operators.
      The return value of such expressions is either `True` or `False`.

      | Operator | Description              |
      | :------- | :----------------------- |
      | `==`     | equal                    |
      | `!=`     | not equal                |
      | `>`      | greater than             |
      | `<`      | less than                |
      | `>=`     | greater than or equal to |
      | `<=`     | less than or equal to    |

   2. If the conditional statement evaluates to `True` increment `vehicle_count` by one (`1`).

   3. After the loop terminates, return `vehicle_count` to the caller.

2. Return to `main()` and call the function `count_vehicles_by_range()`. Pass the appropriate
   arguments to obtain a count of vehicles with a battery ranger greater than or equal to `205`
   miles. Assign the return value of the function call to a variable named `vehicle_count`.

3. Uncomment the accompanying call to `print()` and the `assert` statement. Run your code and
   confirm that `vehicle_count` has been assigned the correct integer value.

## 5.0 `if-else` conditions

Execution of an `if` statement's indented code block occurs _only_ if the condition to be tested
evaluates to `True`. If `False` is returned and a need exists to execute other statements in
response, an `else` statement can be added together with an indented code block.

```commandline
if < condition >:
    < statement A >
    # ...
else:
    < statement B >
    # ...
```

In the example below, the `if-else` block evaluates each vehicle's "type"; if the vehicle is
classified as a "Sedan/Wagon" a string representation of the vehicle (i.e., "< make > < model >") is
appended to the list named `sedan_wagon`. Otherwise, string representations of all other vehicle
types encountered are appended to the list named `suv_pickup`.

```python
sedan_wagon = []
suv_pickup = []
for vehicle in vehicles:
   make_model = get_make_model(vehicle)
   if vehicle[headers.index("type")] == "Sedan/Wagon":
      sedan_wagon.append(make_model)
   else:
      suv_pickup.append(make_model)
```

A second example illustrates how to check if a value exists _between_ a range of values. Assume that
the automotive industry considers an EV battery range between 225-325 mpge (inclusive) as a
"standard" range. Any EV battery ranges that fall on either side of the standard range are
considered _outliers_. You can determine the number of standard and outlier EV battery ranges in
`vehicles` by implementing the following `if-else` statements:

```python
standard_ranges = []
outlier_ranges = []
for vehicle in vehicles:
   make_model = f"{get_make_model(vehicle)} (range = {vehicle[5]} mi)"
   range_mi_idx = headers.index("range_mi")  # lookup index
   if 225 <= int(vehicle[range_mi_idx]) <= 325:
      standard_ranges.append(make_model)
   else:
      outlier_ranges.append(make_model)
```

The conditional statement is built around the expression

```python
if 225 <= int(vehicle[range_mi_idx]) <= 325:
```

The expression evaluates whether or not a given EV battery range falls __between__ `225` and `325`
mpge (inclusive).

:bulb: __Inclusive__ is interpreted as encompasing the values `225` and `325` together with all other
values between the minimum and maximum values (or lower and upper bounds). If the minimum and/or
maximum values are considered __exclusive__ (i.e., outside the range of values under consideration)
use the less than or equal to (`<`) or greater than or equal to (`>`) comparison operators in the
expression.

### 5.1 Challenges

#### 5.1.1 Challenge 06

__Task__: Return counts of domestic and foreign designed EVs.

Assume that EVs are designed&mdash;though not necessarily manufactured&mdash;in the automaker's country of
origin. For this challenge you will employ the `us_automakers` list as a filter that permits you
to distinguish between US and foreign automakers.

```python
us_automakers = [
    "Cadillac",
    "Chevrolet",
    "Ford",
    "Lucid",
    "Polestar Automotive USA",
    "Rivian",
    "Tesla",
]
```

1. In `main()`, the accumulator variables named `domestic_count` and `foreign_count` have both been
   assigned the "start" value zero (`0`).

2. Loop over the `vehicles` list. Implement an `if` statment that embeds a call to the function
   `is_domestic()`. Pass both the nested vehicle list (e.g., `vehicle`) and the `us_automakers` list
   to the function. The function `is_domestic()` will return `True` if the vehicle is designed
   domestically (otherwise it returns `False`). Add a statement in the `if` block that increments
   the current `domestic_count` value by one (`1`).

   :bulb: Recall that a function call is an _expression_ and functions that returns a boolean value
   can be embedded in a conditional statement.

3. Add a companion `else` statement. In the `else` block add a statement that increments the current
   `foreign_count` value by one (`1`).

4. Uncomment the accompanying `print()` function calls, run your code, and check your work.

#### 5.1.2 Challenge 07

__Task__: Assume a budget of $45,000.00 (USD) determines which electric vehicles are affordable
and which are considered unaffordable for the average consumer. Produce __two lists__ of strings
that represent the two groups of vehicles.

1. In `main()`, utilize the empty "accumulator" lists named `affordable` and `unaffordable` to store
   the two groups of vehicles.

2. Inside the `for` loop, return a new version of the `msrp` string that __removes__ both the
   leading `$` sign and the thousands comma (`,`). For example, an msrp string value of `"$46,990"`
   would be converted to `"46990"`. Assign the expression to the variable `msrp`.

3. Convert the `msrp` string to an integer. Assign the return value to the variable `msrp`.

   :bulb: Steps `2` and `3` can be combined into a single expression.

4. Call the function `get_make_model()` and pass it the appropriate argument to return the make and
   model of the vehicle. Assign the return value of the function call to a local variable named
   `make_model`.

5. Implement `if-else` statements that populate the `affordable` and `unaffordable` lists with
   `make_model` according to the following condition:

   If a vehicle's `msrp` is __less than or equal to__ `45000` add `make_model` to the `affordable`
   list. Otherwise, add `make_model` to the `unaffordable` list.

6. Uncomment the accompanying `print()` function calls, run your code, and check your work.

## 6.0 `if-elif-else` conditions

Multiple conditions can be specified by including one or more `elif` conditions in between
an `if-else` block. The `if-elif-else` statement chain or ladder is executed from the top downwards.

```python
if < condition >:
    # < statement A >
    # ...
elif < condition >:
    < statement B >
    # ...
elif < condition >:
    < statement C >
    # ...
else:
    < statement D >
    # ...
```

The `else` statement is _optional_ but recommended, especially for new programmers, in order to
render explicit the conditional logic to be evaluated. You can also nest `if-elif-else` statement
blocks. We will explore nested conditional statements during a later lesson.

In the following example, the `if-elif-else` blocks inside the `for` loop evaluate each vehicle's
"drivetrain" (all wheel drive, front wheel drive, rear wheel drive) and increments the appropriate
accumulator variable (`awd_count`, `fwd_count`, `rwd_count`, `unknown_count`) whenever a match is
obtained.

```python
awd_count = 0
fwd_count = 0
rwd_count = 0
unknown_count = 0
for vehicle in vehicles:
   drivetrain = vehicle[headers.index("drivetrain")]
   if drivetrain == "AWD":
      awd_count += 1
   elif drivetrain == "FWD":
      fwd_count += 1
   elif drivetrain == "RWD":
      rwd_count += 1
   else:
      unknown_count += 1
```

A second example explores the relationship between an electric vehicle's battery capacity and its
range in miles. The example below categorizes EVs into four groups based on the watt-hours per range
mile. The `watt_hours` variable is calculated by multiplying the battery capacity in kilowatt-hours
by `1000`. The `watts_mi` variable is calculated by dividing `watt_hours` by the vehicle's range in
miles. The vehicles are then categorized into four groups based on their `watts_mi` value.

:bulb: Given that all `watts_mi` intervals are covered by the `if-elif-else` blocks, the `else`
block is not required.

```python
watts_mi_low = []
watts_mi_med = []
watts_mi_high = []
watts_mi_vhigh = []
for vehicle in vehicles:
   watt_hours = int(vehicle[headers.index("battery_kwh")]) * 1000
   range_mi = int(vehicle[headers.index("range_mi")])
   watts_mi = round(watt_hours / range_mi, 2)
   make_model_watts = f"{get_make_model(vehicle)} ({watts_mi} watts/mi)"
   if watts_mi < 250:
      watts_mi_low.append(make_model_watts)
   elif 250 <= watts_mi < 300:
      watts_mi_med.append(make_model_watts)
   elif 300 <= watts_mi < 350:
      watts_mi_high.append(make_model_watts)
   elif watts_mi >= 350:
      watts_mi_vhigh.append(make_model_watts)
```

### 6.1 Challenges

#### 6.1.1 Challenge 08

__Task__: Compute the average battery range for each drivetrain.

1. In `main()`, loop over the `vehicles` list. Inside the loop block, note the `drivetrain` variable
   assignment. Access the vehicle's "range_mi" value. Assign the value to the variable `range_mi`.

2. Implement `if-elif-else` blocks that evaluate each `drivetrain` value ("AWD", "FWD", "RWD").
   Inside each block, append the `range_mi` value to the appropriate accumulator list.

3. After the loop terminates, calculate the average range in miles for each drivetrain by dividing
   the __sum__ of the `range_mi` values stored in each accumulator list by the length of the
   corresponding accumulator list. Assign the result of each division operation to the appropriate
   accumulator variable.

   :bulb: The built-in `sum()` function can be employed to calculate the sum of a list of numbers.

   ```python
   < drivetrain>_avg_range = sum(< list >) / len(< list >)
   ```

4. Uncomment the accompanying `print()` function calls, run your code, and check your work.

## 7.0 Looping with the `range` type

Although included among the [built-in functions](https://docs.python.org/3/library/functions.html),
[`range`](https://docs.python.org/3/library/stdtypes.html#typesseq-range) is not a function but an
immutable sequence type like a string, list, or tuple. When instantiated (i.e., created) the `range`
object represents a sequence of numbers that can be looped over.

```commandline
seq = range([start,] stop[, step])
```

You can create an instance of `range` by passing to it an integer `stop` argument. The default
behavior of `range` starts the sequence at zero `0` and then increments by `1` up to
but _excluding_ the specified `stop` value. Optional `start` and `step` arguments can be passed to
`range` including negative step values that reverse the sequence.

### 7.1 `range` behaviors

You can observe how the `range` object behaves by converting the sequence it generates to a list by
passing the `range` object to the built-in `list()` function.

```python
seq = range(10) # instantiate the range object with a stop argument of 10

seq = list(range(10)) # returns [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

seq = list(range(5, 10)) # returns [5, 6, 7, 8, 9]

seq = list(range(5, 21, 5)) # returns [5, 10, 15, 20]

seq = list(range(20, 4, -5)) # returns [20, 15, 10, 5]
```

### 7.2 The `for` loop and `range`

You can use the `range` object to specify the maximum number of `for` loop iterations. In the
following looping example, the expression `range(5)` returns the numeric sequence `0, 1, 2, 3, 4`.
Consequently, the built-in function `print()` is called a total of five (5) times before the loop
terminates.

```python
for i in range(5):
    print("I want an EV!")
```

You can also pass the built-in function `len(< sequence >)` to `range` in a `for` loop in order to
limit the number of loop iterations to the length of the list. Doing so aligns the numeric sequence
returned by `range` (`0, 1, 2, ...`) to the index values of the list elements.

```python
automakers = [
    "Bayerische Motoren Werke AG",
    "Ford Motor Co.",
    "General Motors Co.",
    "Kandi Technologies Group",
    "Nissan Motor Co.",
    "Volkswagen AG",
    "Volvo Group",
    "Tesla, Inc."
    ]

for i in range(len(automakers)):
    print(f"{i} {automakers[i]}")
```

:exclamation: Note that the above `for` loop __does not__ loop over `automakers`; it loops over the
sequence of numbers generated by `range`. Inside the loop block each number (referenced by the
variable `i`) is utilized as an index to access each element in `automakers` by position.

### 7.3 Employing `range` to replace list elements

If you need to replace a list element with another value utilize a `for i in range():` loop to
accomplish the task. Employing a regular `for` loop to perform the assignment will not change the
underlying element, it only repoints the loop variable to the new value
_leaving the underlying element unchanged_.

```python
for automaker in automakers:
    automaker = automaker.upper() # assigns new string to loop variable only

# List elements are unchanged
# [
#     "Bayerische Motoren Werke AG",
#     "Ford Motor Co.",
#     "General Motors Co.",
#     ...
# ]
```

Looping over the numeric sequence generated by `range` permits one to reference each targeted list
element by its index. The assignment of a new value can then be performed successfully.

```python
for i in range(len(automakers)):
    automakers[i] = automakers[i].upper() # assigns new string to element
```

If you need to target select elements for modification you can pass `start` and `step` values to
`range` as in the following example:

```python
# Modify every third element commencing from index 0
for i in range(0, len(automakers), 3):
    automakers[i] = automakers[i].lower() # assigns new string element
```

### 7.4 Subscript operator chaining

Accessing nested list attributes by position is achieved using subscript operator chaining.
Obtaining the Tesla Model 3 AWD EV's range value from the `vehicles` list is achieved by first
accessing the nested list by its index position (`-1`) and then accessing the vehicle's
range value by its index position (`4`) in a "chained" expression.

```python
# ["model", "type", "drivetrain", "fuel_ec_mpge", "range_mi", "battery_kwh", "seats", "base_msrp"],
# ["Tesla Model 3 AWD", "Sedan/Wagon", "AWD", "131", "358", "84", "5", "$46,990"],

tesla_3_range = vehicles[-1][5]
```

In the next example, subscript operator chaining relies on the loop variable `i` (an integer) to
access each nested electric vehicle list in `vehicles`:

```python
tesla_s_range = 0
for i in range(len(vehicles)):
    if vehicles[i][1].lower() == "model s":
        tesla_s_range = vehicles[i][5]
```

:exclamation: In line with method chaining each chained expression employing the subscript operator
(`[]`) resolves to a value. Be mindful when calling a method on the value, you can trigger an
`AttributeError` if you lose track of the value's type and call a method not possessed by the type.

### 7.5 Challenges

#### 7.5.1 Challenge 09

__Task__: Reimplement a `for` loop using the `range` type.

1. Earlier, a standard `for` loop was employed to create two groups of electric vehicles
   (Sedan/Wagon, SUV/Pickup). Copy the commented out `for` loop, paste it below the original, and
   uncomment the copy.

2. Convert the `for` loop to use the `range` type. Utilize `range` to loop over
   __a sequence of numbers__ keyed to the number of elements in `vehicles`. Set the stop value of
   `range` to the length of the `vehicles` list. Utilize the loop variable `i` to represent each
   number to be traversed in `range`.

3. Inside the `for` loop, replace the `vehicle` variable with an expression that can access each
   __nested list__ in `vehicles`.

4. Uncomment the accompanying calls to `print()`. Run your code and confirm that `sedan_wagon` and
   `suv_pickup` contain the correct elements.

#### 7.5.2 Challenge 10

__Task__: Implement a function that returns a list of _unique_ EV vehicle types from a provided
list of electric vehicles. Utilize the accumulator pattern, `range`, the built-in function `len()`,
subscript operator chaining, and the appropriate membership operator to populate a list of _unique_
EV vehicle types (i.e., `["Sedan/Wagon", "SUV", "Pickup"]`).

1. Implement the function named `get_ev_types()`. The function is provisioned with a single
   parameter:

   * `vehicles` (`list`): Nested lists that represent individual vehicles.

   __Requirements__

   1. Inside the function, note the empty accumulator list named `ev_types`. You will use this list
      to accumulate unique EV vehicle type strings.

   2. Utilize `range` to loop over __a sequence of numbers__ keyed to the number of elements in the
      passed in `vehicles` list. Set the stop value of `range` to the length of the `vehicles` list.
      Utilize the loop variable `i` to represent each number to be traversed in `range`.

   3. Inside the loop block, utilize the loop variable `i` to access each nested list in `vehicles`
      together with subscript operator chaining to access the nested list's "type" value. Assign
      the value accessed to a local variable named `ev_type`.

   4. Next, implement an `if` statement that confirms that `ev_type` has __yet to be appended__ to
      the `ev_types` list. Employ the appropriate __membership operator__ (e.g., `in` or `not in`)
      to evaluate whether or not `ev_type` is present in the `ev_types` list.

      :exclamation: The conditional statement _must_ ensure that no duplicate values are added to
      the `ev_types` list.

   5. If `ev_type` has __yet to be appended__ to `ev_types`, add the value to the list.

   6. After the loop terminates, return the `ev_types` list to the caller.

2. Call the function `get_ev_types()` and pass to it `vehicles` as the argument. Assign the return
   value to the variable `ev_types`.

3. Uncomment the accompanying call to `print()` and the `assert` statement. Run your code and
   confirm that `ev_types` contains the correct elements.

#### 7.5.3 Challenge 11

__Task__: Use a `for` loop, `range`, the built-in function `len()`, and subscript operator chaining
to replace the vehicle type "SUV" with the string "Sports Utility Vehicle".

1. Utilize `range` to loop over a sequence of numbers keyed to the number of elements in
   `vehicles`. Utilize the loop variable `i` to represent each number to be traversed in `range`.

2. Inside the `for` loop, implement an `if` statement that evaluates whether or not a vehicle is
   categorized as an SUV (i.e., a Sports Utility Vehicle). Use subscript operator chaining to access
   the "type" value of each nested list in `vehicles`.

3. If the vehicle is an SUV, employ subscript operator chaining to replace the vehicle's "SUV"
   string with the string "Sports Utility Vehicle".

   Below is an example of a modified vehicle list:

   ```python
   ["BMW iX M60", "Sports Utility Vehicle", "AWD", "78", "288", "111", "5", "$108,900"]
   ```

4. Uncomment the built-in function `print()` and check your work.
